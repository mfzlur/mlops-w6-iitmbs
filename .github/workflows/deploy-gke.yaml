name: Build, Deploy, and Stress Test Iris API

on:
  push:
    branches:
      - main

env:
  PROJECT_ID: ${{ secrets.GKE_PROJECT }}
  REPO_NAME: 'mlops-w6-repo'       # <-- Make sure this is your Artifact Registry repo name
  CLUSTER_NAME: 'week6-mlops-iitmbs'  # <-- !!! CHANGE THIS to your GKE cluster name
  CLUSTER_ZONE: us-central1        # <-- Make sure this is your cluster's zone
  IMAGE_NAME: iris-api

jobs:
  build:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    permissions:
      contents: 'read'
      id-token: 'write'

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Authenticate to Google Cloud
      uses: 'google-github-actions/auth@v2'
      with:
        credentials_json: '${{ secrets.GKE_SA_KEY }}'

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Configure Docker for Artifact Registry
      run: gcloud auth configure-docker us-central1-docker.pkg.dev

    - name: Build and Push Docker Image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile
        push: true
        tags: |
          us-central1-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.REPO_NAME }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
          us-central1-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.REPO_NAME }}/${{ env.IMAGE_NAME }}:latest

  deploy:
    name: Deploy to GKE
    runs-on: ubuntu-latest
    needs: build
    permissions:
      contents: 'read'
      id-token: 'write'

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Authenticate to Google Cloud
      uses: 'google-github-actions/auth@v2'
      with:
        credentials_json: '${{ secrets.GKE_SA_KEY }}'

    - name: Get GKE credentials
      uses: 'google-github-actions/get-gke-credentials@v2'
      with:
        cluster_name: ${{ env.CLUSTER_NAME }}
        location: ${{ env.CLUSTER_ZONE }}

    - name: Update Image Tag in Deployment
      run: |
        # This command finds the 'latest' image tag in your deployment.yaml and replaces it
        # with the specific commit SHA, ensuring the new code is deployed.
        sed -i "s|image: us-central1-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.REPO_NAME }}/${{ env.IMAGE_NAME }}:latest|image: us-central1-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.REPO_NAME }}/${{ env.IMAGE_NAME }}:${{ github.sha }}|g" deployment.yaml

    - name: Deploy Kubernetes Manifests
      run: |
        kubectl apply -f deployment.yaml

  stress-test:
    name: Stress Test Application
    runs-on: ubuntu-latest
    needs: deploy
    permissions:
      contents: 'read'
      id-token: 'write'
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Authenticate to Google Cloud
      uses: 'google-github-actions/auth@v2'
      with:
        credentials_json: '${{ secrets.GKE_SA_KEY }}'

    - name: Get GKE credentials
      uses: 'google-github-actions/get-gke-credentials@v2'
      with:
        cluster_name: ${{ env.CLUSTER_NAME }}
        location: ${{ env.CLUSTER_ZONE }}

    - name: Install wrk
      run: |
        sudo apt-get update
        sudo apt-get install -y wrk

    - name: Get Service External IP
      run: |
        echo "--- Waiting for external IP..."
        SERVICE_NAME="iris-api-service"
        IP=""
        TIMEOUT_SECONDS=300 # 5 minutes
        START_TIME=$SECONDS
        
        while [ -z "$IP" ]; do
          CURRENT_TIME=$SECONDS
          ELAPSED=$((CURRENT_TIME - START_TIME))
          
          if [ $ELAPSED -gt $TIMEOUT_SECONDS ]; then
            echo "--- TIMEOUT: Failed to get external IP in 5 minutes. ---"
            kubectl get service $SERVICE_NAME
            exit 1
          fi

          IP=$(kubectl get service $SERVICE_NAME -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null)
          [ -z "$IP" ] && echo "Waiting for IP..." && sleep 10
        done
        
        echo "SERVICE_IP=$IP" >> $GITHUB_ENV
        echo "--- Service IP found: $IP"

    - name: TEST 1  AUTOSCALING DEMO (1000 connections)
      run: |
        echo "--- Test 1: Running >1000 connections with max 3 pods ---"
        echo "--- HPA status before test (expect 1 replica): ---"
        kubectl get hpa iris-api-hpa
      
        echo "--- Applying 1200-connection load for 30s... ---"
        wrk -t4 -c1200 -d30s -s ./scripts/post.lua http://${{ env.SERVICE_IP }}
      
        echo "--- Load test finished. ---"
        echo "--- Test 1 finished. Waiting for HPA to scale to 3 replicas... ---"
        
        REPLICAS=0
        TIMEOUT_SECONDS=240 # 4 minutes
        START_TIME=$SECONDS
        
        while [ "$REPLICAS" -lt 3 ]; do
          CURRENT_TIME=$SECONDS
          ELAPSED=$((CURRENT_TIME - START_TIME))
          
          if [ $ELAPSED -gt $TIMEOUT_SECONDS ]; then
            echo "--- TIMEOUT: HPA did not scale to 3 replicas in 4 minutes. ---"
            kubectl get hpa iris-api-hpa
            kubectl get pods -l app=iris-api -o wide
            exit 1 # Fail the job
          fi
          
          REPLICAS=$(kubectl get hpa iris-api-hpa -o jsonpath='{.status.currentReplicas}' 2>/dev/null || echo 0)
          [ "$REPLICAS" -lt 3 ] && echo "Current replicas: $REPLICAS. Waiting..." && sleep 10
        done
      
        echo "--- HPA scaled to 3 replicas. ---"
        echo "--- Final HPA status (expect 3 replicas): ---"
        kubectl get hpa iris-api-hpa
      
        echo "--- Final pod status and CPU load (expect 3 pods, load distributed): ---"
        kubectl get pods -l app=iris-api -o wide
        kubectl top pods -l app=iris-api

    - name: TEST 2 BOTTLENECK DEMO (2000 connections)
      run: |
        echo "---  Test 2: Restricting to 1 pod, running 2000 connections ---"
        echo "--- HPA status BEFORE patch (expect max 3): ---"
        kubectl get hpa iris-api-hpa
        
        # This is the key command to restrict scaling
        kubectl patch hpa iris-api-hpa --patch '{"spec":{"maxReplicas":1}}'
        echo "--- HPA status AFTER patch (expect max 1): ---"
        kubectl get hpa iris-api-hpa
        
        echo "--- Waiting for pods to scale down to 1... ---"
        REPLICAS=99 # Set to a non-1 value
        TIMEOUT_SECONDS=240 # 4 minutes
        START_TIME=$SECONDS
        
        while [ "$REPLICAS" -ne 1 ]; do
          CURRENT_TIME=$SECONDS
          ELAPSED=$((CURRENT_TIME - START_TIME))

          if [ $ELAPSED -gt $TIMEOUT_SECONDS ]; then
            echo "--- TIMEOUT: Pods did not scale down to 1 in 4 minutes. ---"
            kubectl get pods -l app=iris-api
            exit 1 # Fail the job
          fi

          # Get count of pods that are not Terminating
          REPLICAS=$(kubectl get pods -l app=iris-api --no-headers 2>/dev/null | grep -c -v "Terminating" || echo 0)
          [ "$REPLICAS" -ne 1 ] && echo "Current pod count: $REPLICAS. Waiting..." && sleep 10
        done
        
        echo "--- Pod count is 1. Starting bottleneck test with 2000 connections... ---"
        kubectl get pods -l app=iris-api
        
        # Give pod a moment to settle after scaling down
        sleep 5 
        
        # Apply the heavy load
        wrk -t4 -c2000 -d30s -s ./scripts/post.lua http://${{ env.SERVICE_IP }}
        
        echo "--- Bottleneck test finished. ---"
        echo "*** NOTE: Check 'wrk' output above for high Socket/Timeout errors. This is the bottleneck symptom. ***"
        
        echo "--- CPU load of the single pod (expect CPU to be very high): ---"
        kubectl top pods -l app=iris-api
        
        echo "--- Final HPA status (expect 1/1 replicas, but very high target %): ---"
        kubectl get hpa iris-api-hpa
        echo "*** SUCCESS: HPA shows high CPU target but is 'trapped' at 1 replica. Bottleneck proven. ***"

    - name: Clean Up - Reset HPA
      if: always() # This ensures it runs even if TEST 2 fails
      run: |
        echo "--- Resetting HPA maxReplicas to 3 ---"
        kubectl patch hpa iris-api-hpa --patch '{"spec":{"maxReplicas":3}}'
        echo "--- Final HPA status: ---"
        kubectl get hpa iris-api-hpa
a
